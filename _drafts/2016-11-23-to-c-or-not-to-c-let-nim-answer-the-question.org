#+STARTUP: showall
#+OPTIONS: toc:nil -:nil
---
layout: post
title: To C or not to C? Let Nim answer the question!
tags: nim python
comments: true
---

Python. Elegant, powerful, smart, a true super hero of programming languages. But like any superhero, it must have a weakness, it's weakness is speed. Wise wizard's came up with clever ways to overcome this, some of them going as far as making python fast by not writing python at all(c extensions). While C is fast, such power should not be treated lightly! For those not eager to deal with C hiccups I say *give Nim a try!*.

---

#+CAPTION: Image credits to www.martianpictures.com
#+NAME:   turtle www.martianpictures.com
#+ATTR_HTML: :width 40px
[[http://i.imgur.com/LLp11KJ.png]]

#+TOC: headlines

* Looking for trouble
"Every Fairy Tale Needs A Good Old Fashioned Villain" so our "villain" must be cpu intensive, io intensive as well as being relative easy to explain and somehow similar to a real use case scenario. Eventually I settled on this: 

#+BEGIN_QUOTE 
We have around 1000 Truevision images that we want to open, 
fill the first half with red pixels(simulate a watermark), and finally save it.
#+END_QUOTE

Since it's a batch process, the time it takes to edit each image is critical because each delay will add up to great amounts at the end. To better simulate real world scenarios, we will have to deal with a mixture of image sizes: 15, 150, 512, 1024, 2048 and 4096 pixels wide. Small images to better test JIT sollutions like PyPy, and big one either to help them, again PyPy, or to better see the how well the solution scales.
Before we go further let's take a quick look at what we are dealing with:

** Truevision image format
Truevision TGA, often referred to as TARGA, is a raster graphics file format created by Truevision Inc. I chose it because it uses a simple compression algorithm and it's heavily used in game engines so it has some practical uses.
Here is a oversimplified table representing the format. The byte layout is not important for our case, but it's here to better illustrate what we are dealing with.

| header               | bytes data     | footer           |
|----------------------+----------------+------------------|
| id length            | RLE            | Extension offset | 
| ...                  |      or        | ...              |
| image specifications | no compression | Signature        |

We can either go with compressing the image or not, but for a more demanding benchmark we chose the former over the latter.

** RLE compression algorithm
Wikipedia says it best:
#+BEGIN_QUOTE
Run-length encoding (RLE) is a very simple form of lossless data compression in which runs of data (that is, sequences in which the same data value occurs in many consecutive data elements) are stored as a single data value and count, rather than as the original run. This is most useful on data that contains many such runs.
#+END_QUOTE

A hypothetical scan line, with B representing a black pixel and W representing white, might read as follows:
~WWWWBBBWWBBBBBBW~ 
With a run-length encoding (RLE) data compression algorithm applied to the above hypothetical scan line, it can be rendered as follows:
~4W3B2W6B1W~
* Getting out of trouble
Now that we know our "villain" how can we overcome it? Before getting our hands dirty with C or Nim, maybe we can dodge a bullet by using more "cleaner" ways of getting the required speed. Our mission is not making the fastest implementation yet, we strive for a "good enough" speed, good enough to get our job done without spending to much development power to do that, ideally none.

** [[https://hg.python.org/cpython/file/tip][cPython]] 
The hero we need, the hero we want(well most of the time at least)!

[[https://github.com/MircoT/pyTGA][pyTGA]] is a pure Python module to manage TGA images. The library supports these kind of formats (compressed with RLE or uncompressed):

Grayscale - 8 bit depth

RGB - 16 bit depth

RGB - 24 bit depth

RGBA - 32 bit depth

To ruin the surprise, this will be the slowest of the bunch but it will serve as the reference point for our benchmark while also providing the blueprints for the Nim implementation. By blueprints I meas a almost 1-1 port from Python to Nim. Important to add, I am not the original author of the module, the honor goes to a guy named [[https://github.com/MircoT/pyTGA][Mirco]].

** [[http://nuitka.net/][nuitka]] 
#+BEGIN_QUOTE
Nuitka is a Python compiler.
It's fully compatible with Python 2.6, 2.7, 3.2, 3.3, and 3.4.

You feed it your Python app, it does a lot of clever things, and spits out an executable or extension module.
#+END_QUOTE
If interpreting things is slow, why not compile it? Sounds crazy? think again! The team behind nuitka did just that and what we get is a simple, elegant way of speeding our code, and in some cases it can also help making distribution easyer because it packs everything in a nice ~*.exe~.

~nuitka --recurse-all program.py~ and you are set. ~recurse-all~ option will transverse the dependencies tree and compile them to, one by one.
** [[http://pypy.org/][pypy]] 
#+BEGIN_QUOTE
PyPy is a fast, compliant alternative implementation of the Python language (2.7.12 and 3.3.5). It has several advantages and distinct features, speed, memory usage, compatibility, stackless
#+END_QUOTE
Get a huge speed improvement by just replacing ~python~ with ~pypy~ eg: ~pypy program.py~. To good to be true? Yes, yes it is! Two things: warmup time and incompatibility with all those good python modules written with the help of C. While the pypy team is trying to solve this thing, for now this could be a show stopper for many.
# ** [[http://numba.pydata.org/][numba]] 
# #+BEGIN_QUOTE
# Numba gives you the power to speed up your applications with high performance functions written directly in Python. With a few annotations, array-oriented and math-heavy Python code can be just-in-time compiled to native machine instructions, similar in performance to C, C++ and Fortran, without having to switch languages or Python interpreters.

# Numba works by generating optimized machine code using the LLVM compiler infrastructure at import time, runtime, or statically (using the included pycc tool). Numba supports compilation of Python to run on either CPU or GPU hardware, and is designed to integrate with the Python scientific software stack.
# #+END_QUOTE
# Add a ~@jit~ on stuff you want to go fast and TADA!
** [[http://nim-lang.org/][nim]] 
As the new hero rises, it comes with a promise: *"Performance can also be elegant!"*
#+BEGIN_QUOTE
Nim (formerly known as "Nimrod") is a statically typed, imperative programming language that tries to give the programmer ultimate power without compromises on runtime efficiency. This means it focuses on compile-time mechanisms in all their various forms.
#+END_QUOTE
Before venturing further, you python hackers out there should quickly check out [[https://github.com/nim-lang/Nim/wiki/Nim-for-Python-Programmers][nim for python programmers]], this will come in handy when inspecting the solution implemented in nim that you can find [[https://github.com/BontaVlad/nimtga/blob/master/nimtga.nim][here]]. I am still learning this stuff out, so take everything with a grain of salt, a battle-scarred nim programmer will surely cringe at my source code, but what the hell: "fail fast, fail early, fail often!" as Mozilla like's to say.
Nim produces small executables without dependencies, so calling the code is easy: ~program_bin args~
** [[https://github.com/jboy/nim-pymod][nim-pymod]] 
Now that you fallen in love with Nim, should you replace all you're code base with it? Of course not! Python is great, great packages, great community, great code around it. So why not swap the performance critical part of the code with nim and keep the rest of the goodness in python.
Usually this involves a great deal of boiler-plate code, but lucky we have tools to do that for us, in this case: nim-pymod. Better head over to the project github page for a great introduction, and after that glance at my humble [[https://github.com/BontaVlad/nimtga/blob/master/nimtga.nim][solution]]. Code comments should explain the reason behind some of the code. And for the python wrapper part, check [[https://github.com/BontaVlad/nimtga/blob/master/pymodtga.py][this]].

** Speed comparison
Have I made a decisio: No, Am I intrigued: certainly!
Benchmarking code is [[https://github.com/BontaVlad/nimtga/blob/master/benchmark.py][here]]. I used matplotlib to render the speed comparison diagram.

[[http://i.imgur.com/csyn0lj.png]]
http://i.imgur.com/qvdur1C.png

* Nim: Tell me more!
Aliquam erat volutpat.  Nunc eleifend leo vitae magna.  In id erat non orci commodo lobortis.  Proin neque massa, cursus ut, gravida ut, lobortis eget, lacus.  Sed diam.  Praesent fermentum tempor tellus.  Nullam tempus.  Mauris ac felis vel velit tristique imperdiet.  Donec at pede.  Etiam vel neque nec dui dignissim bibendum.  Vivamus id enim.  Phasellus neque orci, porta a, aliquet quis, semper a, massa.  Phasellus purus.  Pellentesque tristique imperdiet tortor.  Nam euismod tellus id erat.
